{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Argdantic","text":"<p>Typed command line interfaces, powered by argparse and pydantic.</p>"},{"location":"#features","title":"Features","text":"<p><code>argdantic</code> provides a thin boilerplate layer to provide a modern CLI experience, including:</p> <ul> <li> <p>Typed arguments: arguments require full typing by default, enforcing clarity and help your editor provide better support (linting, hinting).</p> </li> <li> <p>Nested models: exploit <code>pydantic</code> models to scale from simple primitives to complex nested configurations with little effort.</p> </li> <li> <p>Nested commands: combine commands and build complex hierarchies to build complex interfaces.</p> </li> <li> <p>Validation by default: thanks to <code>pydantic</code>, field validation is provided by default, with the desired complexity.</p> </li> <li> <p>Multiple sources: arguments can be provided from multiple sources, including environment variables, JSON, TOML and YAML files.</p> </li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#installation","title":"Installation","text":"<p>Installing <code>argdantic</code> can be done from source, or simply using <code>pip</code>. The only required dependency is, of course, pydantic, while the remaining can be selected depending on your needs: <pre><code>recommended choice: install everything\nthis includes orjson, pyyaml, tomli, python-dotenv\nuser@pc:~$ pip install argdantic[all]\n\nenv, json, toml or yaml dependencies\nuser@pc:~$ pip install argdantic[env|json|toml|yaml]\n\nminimum requirement, only pydantic included\nuser@pc:~$ pip install argdantic\n</code></pre></p>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<p>Creating a CLI with <code>argdantic</code> can be as simple as: <pre><code>from argdantic import ArgParser\n\n# 1. create a CLI instance\nparser = ArgParser()\n\n\n# 2. decorate the function to be called\n@parser.command()\ndef buy(name: str, quantity: int, price: float):\n    print(f\"Bought {quantity} {name} at ${price:.2f}.\")\n\n# 3. Use your CLI by simply calling it\nif __name__ == \"__main__\":\n    parser()\n</code></pre> Then, in a terminal, the <code>help</code> command can provide the usual information:</p> <p><pre><code>$ python cli.py --help\n&gt; usage: buy [-h] --name TEXT --quantity INT --price FLOAT\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help      show this help message and exit\n&gt;   --name TEXT\n&gt;   --quantity INT\n&gt;   --price FLOAT\n</code></pre> This gives us the required arguments for the execution: <pre><code>$ python cli.py --name apples --quantity 10 --price 3.4\n&gt; Bought 10 apples at $3.40.\n</code></pre></p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project is heavily inspired by other awesome works, including:</p> <ul> <li> <p>click: the most popular CLI library for Python for complex applications, the best alternative to <code>argparse</code>.</p> </li> <li> <p>typer: based on <code>click</code>, a great project that inspired the creation of <code>argdantic</code>. It is a great alternative, however it does not support <code>pydantic</code> models at the moment.</p> </li> <li> <p>pydantic-cli: a mature project that provides a similar experience to <code>argdantic</code>, however it does not support nested models, commands and different sources.</p> </li> </ul> <p>Do you like <code>argdantic</code>, but prefer <code>click</code> as a CLI library? Check out clidantic, a twin project that uses <code>click</code> instead of <code>argparse</code>.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"guide/composition/","title":"Composition","text":"<p>Exploiting both pydantic and argparse functionality, <code>argdantic</code> allows two types of composition: nested models and nested parsers. The first allows to define complex inputs, building a hierarchy of models and submodels. The second allows to organize your code into a series of commands and subcommands, each with its own set of arguments.</p>"},{"location":"guide/composition/#nested-models","title":"Nested Models","text":"<p>Strictly speaking, every argument stated in the signature of a <code>@command</code> function is wrapped into a pydantic model. This allows two things: first, it makes it easier and more natural for the user to define input arguments, and second, it allows to define complex inputs, building a hierarchy of models and submodels, directly exploiting the powerful features of pydantic.</p> <p>For example, let's say we want to define a command that takes an input <code>Item</code>, which in turn contains an <code>Image</code> model. We can do this by defining two models, and then using the <code>Item</code> model as an argument of the <code>@command</code> function:</p> nested_models.py<pre><code>from typing import Set\n\nfrom pydantic import BaseModel\n\nfrom argdantic import ArgParser\n\n\nclass Image(BaseModel):\n    url: str\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str = None\n    price: float\n    tags: Set[str] = set()\n    image: Image = None\n\n\ncli = ArgParser()\n\n\n@cli.command()\ndef create_item(item: Item):\n    print(item)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Underneath, <code>argdantic</code> will automatically create the following structure:</p> <ul> <li>A nameless root model, inheriting from <code>BaseConfig</code> if any extra feature is enabled, and containing:<ul> <li>A field <code>item</code>, of type <code>Item</code>, which defines:<ul> <li>A field <code>name</code>, of type <code>str</code>,</li> <li>A field <code>description</code>, of type <code>str</code>,</li> <li>A field <code>price</code>, of type <code>float</code>,</li> <li>A field <code>tags</code>, of type <code>Set[str]</code>,</li> <li>A field <code>image</code>, of type <code>Image</code>, which defines:<ul> <li>A field <code>url</code>, of type <code>str</code>,</li> <li>A field <code>name</code>, of type <code>str</code></li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>The resulting command line interface, with the help message, will be the following:</p> <pre><code>$ python nested_models.py --help\n&gt; usage: nested_models.py [-h] --item.name TEXT --item.description TEXT --item.price FLOAT --item.tags TEXT [TEXT ...] --item.image.url TEXT --item.image.name TEXT\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help            show this help message and exit\n&gt;   --item.name TEXT                (required)\n&gt;   --item.description TEXT\n&gt;   --item.price FLOAT              (required)\n&gt;   --item.tags [TEXT [TEXT ...]]   (default: set())\n&gt;   --item.image.url TEXT           (required)\n&gt;   --item.image.name TEXT          (required)\n</code></pre> <p>Note</p> <pre><code>This argument wrapping behaviour is automated by default to make the command definition as natural as possible,\nhowever it is possible to define a custom root model by using the `sigleton` keyword argument\nof the `@command` decorator (See, [] )\n</code></pre> <p>Executing the command with the required arguments will result in the following output:</p> <pre><code>$ python nested_models.py --item.name \"My Item\" \\\n    --item.description \"My Item Description\" \\\n    --item.price 10.0 \\\n    --item.tags \"tag1\" \"tag2\" \\\n    --item.image.url \"https://example.com/image.png\" \\\n    --item.image.name \"My Image\"\n&gt; name='My Item' description='My Item Description' price=10.0 tags={'tag1', 'tag2'} image=Image(url='https://example.com/image.png' name='My Image')\n</code></pre> <p>Note</p> <p>Despite that the <code>Image</code> model defaults to <code>None</code>, you will notice that its fields are still required. Strictly speaking, that's the correct behavior, since these fields are not optional. This would have also happened if the <code>image</code> field had an explicit <code>Image()</code> default value.</p> <p>This is a very simple example, but it shows how to define complex inputs, and how to exploit the power of pydantic to define a hierarchy of models. In fact, you can define as many levels of nesting as you want, building a complex configuration that can be easily validated and parsed. Nested configurations are also supported using different input sources, such as environment variables and configuration files: see the Input Sources section for more details.</p>"},{"location":"guide/composition/#singleton-configurations","title":"Singleton Configurations","text":"<p>Sometimes it may be useful to define a single configuration object manually, and then use it as the main input argument of a command. For instance, imagine a machine learning pipeline with a single <code>config</code> object, that can be customized from command line, passed to each step of the pipeline, and then dumped to a file for future reference.</p> <p>This can be done by defining a custom model, and then by simply activating the <code>singleton</code> keyword argument of the <code>@command</code> decorator:</p> singleton_config.py<pre><code>from datetime import date\nfrom typing import List\n\nfrom pydantic import BaseModel\n\nfrom argdantic import ArgParser\n\n\nclass Image(BaseModel):\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: str\n    image: Image | None = None\n    dates: List[date]\n\n\ncli = ArgParser()\n\n\n@cli.command(singleton=True)\ndef create_item(item: Item):\n    print(item)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Argdantic will then use the defined argument as the root model, without wrapping it into a new one. This has the added benefit of removing the top-level name from the CLI fields, which would be all the same in this case. Note the absence of the <code>item</code> name in front of the following fields:</p> <pre><code>$ python singleton.py --help\n&gt; usage: test.py [-h] --name TEXT --description TEXT --image.name TEXT\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help          show this help message and exit\n&gt;   --name TEXT         (required)\n&gt;   --description TEXT  (required)\n&gt;   --image.name TEXT   (required)\n</code></pre> <p>Warning</p> <p>The <code>singleton</code> configuration setup only works when two requirements are met: first, only one argument must be defined in the signature of the <code>@command</code> function, and second, that argument must be a pydantic model. Failure to meet these requirements will result in an <code>AssertionError</code> being raised.</p>"},{"location":"guide/composition/#nested-parsers","title":"Nested Parsers","text":"<p><code>argdantic</code> also allows to organize your code into a series of commands and subcommands, each with its own set of arguments. A single parser is enough to define a list of commands at the same level. However, sometimes it is necessary to define a hierarchy of commands, such as <code>git commit</code> and <code>git push</code>.</p> <p>This can be done by defining multiple parsers, each with its own set of commands, and then merging them together, like so:</p> nested_parsers.py<pre><code>from argdantic import ArgParser\n\nusers = ArgParser(name=\"users\")\nbooks = ArgParser(name=\"books\")\n\n\n@users.command()\ndef add_user(name: str, age: int):\n    \"\"\"Adds a single user.\"\"\"\n    print(f\"Adding user: {name} ({age})\")\n\n\n@users.command()\ndef delete_user(name: str):\n    \"\"\"Deletes a user by name.\"\"\"\n    print(f\"Deleting user: {name}\")\n\n\n@books.command()\ndef add_book(name: str, author: str):\n    \"\"\"Adds a book, with name and author.\"\"\"\n    print(f\"Adding book: {name} ({author})\")\n\n\n@books.command()\ndef delete_book(name: str):\n    \"\"\"Deletes a book by name.\"\"\"\n    print(f\"Deleting book: {name}\")\n\n\ncli = ArgParser()\ncli.add_parser(users)\ncli.add_parser(books)\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>There are a few things to notice here:</p> <ul> <li> <p>The subparsers must have a name, which is used to identify them when calling the CLI.    This can be provided by either providing a <code>name</code> during instantiation, or by passing a <code>name</code> keyword argument to the <code>add_parser</code> method.</p> </li> <li> <p>In general, the main parser does not require a name, unless it is used as a subparser of another parser.</p> </li> </ul> <p>When executing the <code>help</code> command, the following output will be produced:</p> <pre><code>$ python nested_parsers.py --help\n&gt; usage: nested_parsers.py [-h] &lt;command&gt; ...\n&gt;\n&gt; positional arguments:\n&gt;   &lt;command&gt;\n&gt;     users\n&gt;     books\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help  show this help message and exit\n</code></pre> <p>Note</p> <p>The description provided by the <code>help</code> command is quite limited at the moment: as you can see, the name of the subparsers is shown, but not their description. This is a known limitation, and it will be addressed in the future.</p> <p>The same can be done on the subgroup, calling the <code>help</code> command on the <code>users</code> subparser:</p> <pre><code>$ python nested_parsers.py users --help\n&gt; usage: nested_parsers.py users [-h] &lt;command&gt; ...\n&gt;\n&gt; positional arguments:\n&gt;   &lt;command&gt;\n&gt;     add-user   Adds a single user.\n&gt;     delete-user\n&gt;                Deletes a user by name.\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help   show this help message and exit\n</code></pre> <p>Finally, the <code>help</code> command can be called on the subcommand, showing the description and the arguments:</p> <pre><code>$ python nested_parsers.py users add-user --help\n&gt; usage: nested_parsers.py users add-user [-h] --name TEXT --age INT\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help   show this help message and exit\n&gt;   --name TEXT  (required)\n&gt;   --age INT    (required)\n</code></pre> <p>Last but not least, the command can be executed, by passing the required arguments:</p> <pre><code>$ python nested_parsers.py users add-user --name \"John Doe\" --age 30\n&gt; Adding user: John Doe (30)\n</code></pre> <p>Of course, nested models and nested parsers can be combined together, to create a complex hierarchy of commands and arguments. Fantasy is the limit, well, at least until you run out of RAM.</p>"},{"location":"guide/customization/","title":"Customization","text":"<p>Argdantic supports a number of customization options, which can be used to change the default behavior of the CLI. Being based on <code>argparse</code> and <code>pydantic</code>, the customization options are limitless, however the most common ones are listed below.</p> <ul> <li>Command names: a custom help message to be displayed when the <code>--help</code> flag is passed.</li> <li>Command description: a custom help message to be displayed when the <code>--help</code> flag is passed.</li> <li>Field descriptions: a custom help message to be displayed when the <code>--help</code> flag is passed.</li> <li>Field aliases: a list of optional names that can be used instead of the field name.</li> <li>Field default values: a default value to be used when the field is not provided.</li> </ul> <p>The following sections will provide a brief overview of these options, and how to use them.</p>"},{"location":"guide/customization/#command-names","title":"Command Names","text":"<p>By default, the name of the function that is decorated with <code>@parser.command()</code> is used as the name of the command. This can be changed by passing a <code>name</code> argument to the decorator:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command(name=\"greetings\")\ndef hello(name: str):\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When executed, the script will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] --name TEXT\n&gt;\n&gt; optional arguments:\n&gt;  -h, --help   show this help message and exit\n&gt;  --name TEXT  (required)\n</code></pre> <p>Wait a minute, where is the custom name?</p> <p>By default, with only one command, the name of the command is not displayed, nor used to execute the command. This can be changed by:</p> <ol> <li>Registering more than one command, the easiest option.</li> <li>By passing the <code>force_group</code> argument to the parser.</li> </ol>"},{"location":"guide/customization/#multiple-commands","title":"Multiple Commands","text":"<p>When more than one command is registered, its name is required to execute that specific CLI function. For instance, the following script:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command(name=\"hi\")\ndef hello(name: str):\n    \"\"\"\n    Say hello.\n    \"\"\"\n    print(f\"Hello, {name}!\")\n\n\n@cli.command(name=\"bye\")\ndef goodbye(name: str):\n    \"\"\"\n    Say goodbye.\n    \"\"\"\n    print(f\"Goodbye, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When executed, the script will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] &lt;command&gt; ...\n&gt;\n&gt; positional arguments:\n&gt;   &lt;command&gt;\n&gt;     hi        Say hello.\n&gt;     bye       Say goodbye.\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help  show this help message and exit\n</code></pre> <p>The <code>hi</code> and <code>bye</code> commands are now available, and can be executed by passing their name as the first argument:</p> <pre><code>$ python main.py hi --name John\n&gt; Hello, John!\n</code></pre> <p>You also probably noticed that the commands also provide a description. This can be customized in many ways, and will be covered in the next section.</p>"},{"location":"guide/customization/#forced-groups","title":"Forced Groups","text":"<p>The <code>force_group</code> argument can be used to force the creation of a group, even if only one command is registered. This can be useful if you want to force users to provide the command name upon execution.</p> <p>For instance, the following script:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser(force_group=True)\n\n\n@cli.command(name=\"greetings\")\ndef hello(name: str):\n    \"\"\"\n    Say hello.\n    \"\"\"\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When executed, the script will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] &lt;command&gt; ...\n&gt;\n&gt; positional arguments:\n&gt;   &lt;command&gt;\n&gt;     greetings\n&gt;               Say hello.\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help  show this help message and exit\n</code></pre> <p>The <code>greetings</code> command is now available, and can be executed by passing its name as the first argument:</p> <pre><code>$ python main.py greetings --name John\n&gt; Hello, John!\n</code></pre>"},{"location":"guide/customization/#command-descriptions","title":"Command Descriptions","text":"<p>You may have noticed from the previous example that the commands also provide a description. Descriptions can be customized in two simple ways:</p> <ul> <li> <p>Automatically, by simply providing a docstring to the function.</p> </li> <li> <p>Manually passing a <code>help</code> argument to the <code>@parser.command()</code> decorator.</p> </li> </ul> <p>For instance, the following script:</p> <p>main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser(force_group=True)\n\n\n@cli.command(help=\"Print a greeting message\")\ndef hello(name: str):\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> Is equivalent to:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser(force_group=True)\n\n\n@cli.command()\ndef hello(name: str):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When executed, the scripts will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] &lt;command&gt; ...\n&gt;\n&gt; positional arguments:\n&gt;   &lt;command&gt;\n&gt;     hello     Print a greeting message.\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help  show this help message and exit\n</code></pre>"},{"location":"guide/customization/#default-values","title":"Default Values","text":"<p>Of course, any good CLI tool should provide the user with a way to provide default values for the fields. Given that defining a command is as simple as defining a function, introducing default values can also be as simple as providing a default value to the function arguments. For instance:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(name: str = \"World\", age: int = 42):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"You are {age} years old.\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>This can be executed with no arguments without any issues:</p> <pre><code>$ python main.py\n&gt; Hello, World!\n&gt; You are 42 years old.\n</code></pre> <p>The default values are also provided in the help message, so that the user is informed about them:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] [--name TEXT] [--age INT]\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help   show this help message and exit\n&gt;   --name TEXT  (default: World)\n&gt;   --age INT    (default: 42)\n</code></pre>"},{"location":"guide/customization/#default-values-and-required-fields","title":"Default Values and Required Fields","text":"<p>Of course, if a field provides a default value, it is no longer required. This implies that every field must be assigned in some way, either by providing it beforehand or during execution, which will respectively add a <code>default</code> or <code>required</code> flag to the help message. But, as a famous grand master once said, there is another: when the default is <code>None</code>, the field is neither marked as <code>default</code> nor <code>required</code>, so the help message will not contain any flag. At the time of writing, this is the only way to provide a true optional field.</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(name: str = None, age: int = None):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"You are {age} years old.\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>The help message will now look like this:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] [--name TEXT] [--age INT]\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help   show this help message and exit\n&gt;   --name TEXT\n&gt;   --age INT\n</code></pre> <p>These are very simple examples, but they can be extended to any field, including more complex ones such as <code>List</code>, <code>Dict</code>, and so on. There are also a few other ways to provide default values, which will be covered in the next sections.</p>"},{"location":"guide/customization/#field-options","title":"Field Options","text":"<p>A CLI cannot be complete without a way to customize the fields. <code>argdantic</code> provides a way to customize the fields through the <code>ArgField</code> function, which can be seen as a light wrapper around pydantic's <code>Field</code> with a few changes to make it more suitable for CLI tools. <code>ArgField</code>, on top of the arguments provided by <code>Field</code>, provides the following options:</p> <ul> <li> <p><code>names</code>: A variable list of names to provide aliases for the field. This substitutes the positional default value in pydantic.</p> </li> <li> <p><code>default</code>: A keyword argument to provide a default value for the field. This is now a keyword argument, mirroring <code>argparse</code>.</p> </li> <li> <p><code>description</code>: A keyword argument to provide a description for the field. This uses the same functionality of <code>Field</code>'s <code>description</code>.</p> </li> </ul>"},{"location":"guide/customization/#aliases","title":"Aliases","text":"<p>A common functionality provided by argparse is the ability to provide aliases for the fields. This option is made available in <code>argdantic</code> by using the <code>ArgField</code> modifier to the field. Optional field names can be provided in the following way:</p> main.py<pre><code>from argdantic import ArgField, ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(name: str = ArgField(\"-n\"), age: int = ArgField(\"-a\")):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"You are {age} years old.\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Executing the script with the <code>--help</code> flag will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] --name TEXT --age INT\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help            show this help message and exit\n&gt;   --name TEXT, -n TEXT  (required)\n&gt;   --age INT, -a INT     (required)\n</code></pre> <p>The message now shows to the user that the <code>--name</code> and <code>--n</code> flags are equivalent, as well as the <code>--age</code> and <code>--a</code> flags. Let's try to execute the script with the new flags:</p> <pre><code>$ python main.py -n John -a 42\n&gt; Hello, John!\n&gt; You are 42 years old.\n</code></pre>"},{"location":"guide/customization/#default-with-fields","title":"Default with Fields","text":"<p>Substituting the default value in the function signature with the <code>ArgField</code> modifier does not preclude the use of the default value in the function signature. This is now possible by using the <code>default</code> keyword argument:</p> main.py<pre><code>from argdantic import ArgField, ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(\n    name: str = ArgField(\"-n\", default=\"John\"),\n    age: int = ArgField(\"-a\", default=30),\n):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"You are {age} years old.\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>As before, the script can be executed without any arguments:</p> <pre><code>$ python main.py\n&gt; Hello, World!\n&gt; You are 42 years old.\n</code></pre>"},{"location":"guide/customization/#descriptions","title":"Descriptions","text":"<p>Last but not least, CLI arguments are usually accompanied by a description. This can be provided in the same way as the default value, by using the <code>description</code> keyword argument:</p> main.py<pre><code>from argdantic import ArgField, ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(\n    name: str = ArgField(\"-n\", default=\"John\", description=\"your name\"),\n    age: int = ArgField(\"-a\", default=30, description=\"your age\"),\n):\n    \"\"\"Print a greeting message.\"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"You are {age} years old.\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>This description will be displayed in the help message:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] [--name TEXT] [--age INT]\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help            show this help message and exit\n&gt;   --name TEXT, -n TEXT  your name (default: John)\n&gt;   --age INT, -a INT     your age (default: 30)\n</code></pre>"},{"location":"guide/customization/#other-options","title":"Other Options","text":"<p>There are a few other options that can be provided to the <code>ArgField</code> modifier, which are not covered in this tutorial, but can be found in the <code>pydantic</code> documentation. These include, just to name a few, validators, constraints, and so on. In general, every other argument provided to <code>Field</code> can be provided to <code>ArgField</code> in the same way.</p>"},{"location":"guide/intro/","title":"Introduction","text":""},{"location":"guide/intro/#parsers","title":"Parsers","text":"<p>The main building block of argdantic is represented by a <code>ArgParser</code> instance. Every CLI requires at least one active parser, which serves as main entry point. A parser simply acts as a collection of commands, which are only executed upon call.</p> <p>Any parser must first be imported, instantiated, then called in a main, like so:</p> <p>main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> However, this code is not enough to have a working CLI. If you attempt to run it you will obtain: <pre><code>$ python main.py\n&gt; AssertionError: Parser must have at least one command or group of commands\n</code></pre> This is the expected behavior, as a parser without any command is useless: check the Commands section for more information.</p>"},{"location":"guide/intro/#commands","title":"Commands","text":"<p>Commands are the backbone of any parser. Underneath, they are simply functions that are called when requested by the user. A command can be added to a parser by using the <code>@parser.command()</code> decorator, like so:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello_world():\n    print(\"Hello World!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When executed, the script will provide the following output: <pre><code>$ python main.py\n&gt; Hello World!\n</code></pre> This is a step forward, however the command is still not very useful. Let's see how to add arguments to it.</p>"},{"location":"guide/intro/#arguments","title":"Arguments","text":"<p>Arguments are the way to provide information and dynamic functionality to a command. They are defined by simply adding them to the command's signature, like so:</p> main.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef hello(name: str):\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Note</p> <p>Of course, typing is crucial to ensure that <code>argdantic</code> can correctly parse the arguments. The framework however will be kind enough to provide an error message if a field does not provide a type annotation.</p> <p>When executed, the script will provide the following output: <pre><code>$ python main.py\n&gt; usage: main.py [-h] --name TEXT\n&gt; main.py: error: the following arguments are required: --name\n</code></pre> This is correct, as the <code>--name</code> argument is required. Let's see how to provide it.</p> <pre><code>$ python main.py --name John\n&gt; Hello, John!\n</code></pre>"},{"location":"guide/intro/#help-messages","title":"Help Messages","text":"<p>Of course, randomly executing a command without any information is not very useful. The <code>--help</code> argument is automatically added to every command, and provides a summary of the command's arguments. For instance, running the help command on the previous example will provide the following output:</p> <pre><code>$ python main.py --help\n&gt; usage: main.py [-h] --name TEXT\n&gt;\n&gt; optional arguments:\n&gt;  -h, --help   show this help message and exit\n&gt;  --name TEXT  (required)\n</code></pre> <p>You may have noticed two things: if you are familiar with <code>argparse</code>, you probably already know that the <code>--help</code> argument is automatically added to every command. In addition, <code>argdantic</code> explicitly provides the <code>(required)</code> tag to every argument that does not specify a default value. This is done to ensure that the user is aware of some missing options, even before the command is executed.</p>"},{"location":"guide/sources/","title":"CLI Sources","text":"<p><code>argdantic</code> allows you to define the arguments of your CLI in a variety of ways, including:</p> <ul> <li> <p>Command line arguments, using <code>argparse</code></p> </li> <li> <p>Environment variables or <code>.env</code> files, using python-dotenv</p> </li> <li> <p>Configuration files, using JSON, YAML, or TOML files.</p> </li> </ul> <p>Each of these input sources can be used independently, or in combination with each other. The priority of the input sources is given by the order in which they are defined, with the last one having the highest priority. Of course, the command line arguments always have the highest priority, and they can be used to override any other input source.</p> <p>Since every command is virtually independent, sources are part of the command definition. This means that you can define different sources for different commands or models in the same CLI.</p>"},{"location":"guide/sources/#static-sources","title":"Static Sources","text":"<p>The simplest kind of source is a static source, where the values are defined at the time of the command definition.</p> <p>For instance, the following example defines a single command with many different sources:</p> sources.py<pre><code>from typing import Set\n\nfrom pydantic import BaseModel\n\nfrom argdantic import ArgParser\nfrom argdantic.sources import (\n    EnvSettingsSource,\n    JsonSettingsSource,\n    TomlSettingsSource,\n    YamlSettingsSource,\n)\n\n\nclass Image(BaseModel):\n    url: str = None\n    name: str = None\n\n\nclass Item(BaseModel):\n    name: str = \"test\"\n    description: str = None\n    price: float = 10.0\n    tags: Set[str] = set()\n    image: Image = None\n\n\ncli = ArgParser()\n\n\n@cli.command(\n    sources=[\n        EnvSettingsSource(env_file=\".env\"),\n        JsonSettingsSource(path=\"settings.json\"),\n        YamlSettingsSource(path=\"settings.yaml\"),\n        TomlSettingsSource(path=\"settings.toml\"),\n    ]\n)\ndef create_item(item: Item):\n    print(item)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>If you try to run the command as it is, you will get an error because the JSON and TOML files are not defined. Comment out the lines that define the JSON and TOML sources, and run the command again. You will see that the command runs successfully, and the arguments are taken from the YAML file:</p> <pre><code>$ python sources.py\n&gt; name='example' description='Example item' price=2.3 tags={'example', 'item', 'tag'} image=Image(url='https://example.com/image.jpg', name='example.jpg')\n</code></pre> <p>Warning</p> <p>Support for sources is still experimental, and the API may change in the future. The <code>required</code> flags are currently a limitation for file sources, as they force users to define CLI arguments that may be set via file. Use default values or <code>None</code> as a workaround.</p>"},{"location":"guide/sources/#dynamic-sources","title":"Dynamic Sources","text":"<p>Reading or writing a full configuration from scratch may not be your cup of tea. Sometimes you may want to define a model with its own fields, reading its configuration from a file, while still being able to override some of its fields from the command line.</p> <p>Imagine you have a model like this:</p> models.py<pre><code>from pydantic import BaseModel\n\nclass Fruit(BaseModel):\n    name: str\n    color: str\n    price: float\n</code></pre> <p>The CLI may define a <code>--fruit</code> argument to point to a file with the content of a <code>Fruit</code> instance, as well as a <code>--fruit.name</code> argument,  or <code>--fruit.color</code> argument, etc.</p> <p>In argdantic, you can do that with the <code>from_file</code> annotation.</p> dynamic.py<pre><code>from pydantic import BaseModel\n\nfrom argdantic import ArgParser\nfrom argdantic.sources import YamlFileLoader, from_file\n\n\n@from_file(loader=YamlFileLoader)\nclass Optimizer(BaseModel):\n    name: str = \"SGD\"\n    learning_rate: float = 0.01\n    momentum: float = 0.9\n\n\n@from_file(loader=YamlFileLoader)\nclass Dataset(BaseModel):\n    name: str = \"CIFAR10\"\n    batch_size: int = 32\n    tile_size: int = 256\n    shuffle: bool = True\n\n\ncli = ArgParser()\n\n\n@cli.command()\ndef create_item(dataset: Dataset, optim: Optimizer):\n    print(dataset)\n    print(optim)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>without additional configuration, the <code>from_file</code> decorator will automatically add an extra argument, equal to the name of the field, to the command line interface, in this case <code>--dataset</code> and <code>--optim</code>:</p> <p>This will enable two extra arguments, namely <code>--dataset</code> and `--optim:</p> <pre><code>$ python dynamic.py --help\n usage: models.py [-h] [--dataset.name TEXT] [--dataset.batch-size INT] [--dataset.tile-size INT] [--dataset.shuffle | --no-dataset.shuffle] --dataset PATH\n                  [--optim.name TEXT] [--optim.learning-rate FLOAT] [--optim.momentum FLOAT] --optim PATH\n\n options:\n   -h, --help            show this help message and exit\n   --dataset.name TEXT   (default: CIFAR10)\n   --dataset.batch-size INT\n                         (default: 32)\n   --dataset.tile-size INT\n                         (default: 256)\n   --dataset.shuffle     (default: True)\n   --no-dataset.shuffle\n+   --dataset PATH        (required)\n   --optim.name TEXT     (default: SGD)\n   --optim.learning-rate FLOAT\n                         (default: 0.01)\n   --optim.momentum FLOAT\n                         (default: 0.9)\n+   --optim PATH          (required)\n</code></pre> <p>Invoking the command with the <code>--dataset</code> and <code>--optim</code> arguments will read the configuration from the files, which are defined as follows:</p> resources/dataset.yml<pre><code>name: coco\nbatch_size: 32\ntile_size: 512\nshuffle: true\n</code></pre> resources/optim.yml<pre><code>name: \"adam\"\nlearning_rate: 0.001\nmomentum: 0.9\n</code></pre> <pre><code>$ python dynamic.py --dataset resources/dataset.yml --optim resources/optim.yml\n name='coco' batch_size=32 tile_size=512 shuffle=True\n name='adam' learning_rate=0.001 momentum=0.9\n</code></pre>"},{"location":"guide/sources/#customizing-the-from_file-behavior","title":"Customizing the <code>from_file</code> behavior","text":"<p>The <code>from_file</code> decorator has a few options that can be used to customize its behavior:</p> <ul> <li> <p><code>required</code>: If <code>True</code>, the file path is required. If <code>False</code>, the file path is optional. Defaults to <code>True</code>.</p> </li> <li> <p><code>loader</code>: A function that takes as input the model class itself, and the file path, and returns an instance of the model. <code>argdantic</code> provides three built-in loaders:</p> <ul> <li><code>JsonFileLoader</code></li> <li><code>YamlFileLoader</code></li> <li><code>TomlFileLoader</code></li> </ul> </li> <li> <p><code>use_field</code>: When specified, the model field indicated by the string will be used as the file path to look for the configuration. In this case, the extra argument will not be added to the command line interface, and the file path is naturally provided by the pydantic model itself. It may be useful when the file path is needed later on.</p> </li> </ul> <p>Here's an example providing both the <code>required</code> and <code>use_field</code> options:</p> dynamic_custom.py<pre><code>from pathlib import Path\n\nfrom pydantic import BaseModel\n\nfrom argdantic import ArgParser\nfrom argdantic.sources import YamlFileLoader, from_file\n\n\n@from_file(loader=YamlFileLoader, use_field=\"path\")\nclass Optimizer(BaseModel):\n    path: Path\n    name: str = \"SGD\"\n    learning_rate: float = 0.01\n    momentum: float = 0.9\n\n\n@from_file(loader=YamlFileLoader, required=False)\nclass Dataset(BaseModel):\n    name: str = \"CIFAR10\"\n    batch_size: int = 32\n    tile_size: int = 256\n    shuffle: bool = True\n\n\ncli = ArgParser()\n\n\n@cli.command()\ndef create_item(optim: Optimizer, dataset: Dataset = Dataset()):\n    print(dataset)\n    print(optim)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Specifying the following command will read the configuration from the optim instance only:</p> <pre><code>+$ python dynamic_custom.py --optim.path resources/optim.yml\nname='CIFAR10' batch_size=32 tile_size=256 shuffle=True\npath=PosixPath('resources/optim.yml') name='adam' learning_rate=0.001 momentum=0.9\n</code></pre> <p>Notice that the path this time is provided using a standard field, but the loader automatically reads the configuration from the specified file.</p>"},{"location":"guide/types/","title":"Field Types","text":"<p>Thanks to features provided by pydantic's data definitions, <code>argdantic</code> supports a large amount of field types, starting from the standard library up to JSON inputs.</p>"},{"location":"guide/types/#primitive-types","title":"Primitive types","text":"<p>Considering primitive, non-complex data types, the library supports the following:</p> <ul> <li> <p><code>str</code>: values accepted as is, parsed as simple text without further processing.</p> </li> <li> <p><code>int</code>: tries to convert any given input into an integer through <code>int(value)</code>.</p> </li> <li> <p><code>float</code>: similarly, tries to convert any given input into a floating point number through <code>float(value)</code>.</p> </li> <li> <p><code>bytes</code>: similar to strings, however in this case the underlying representation remains in bytes.</p> </li> <li> <p><code>bool</code>: by default, booleans are intended as flag options. In this case any boolean field will have two corresponding CLI flags <code>--field/--no-field</code>.</p> </li> </ul> <p>The following example shows a brief overview of the primitive types:</p> primitives.py<pre><code>from argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef status(name: str, age: int, weight: float, data: bytes, flag: bool):\n    print(f\"name: {name}\")\n    print(f\"age: {age}\")\n    print(f\"weight: {weight}\")\n    print(f\"data: {data}\")\n    print(f\"flag: {flag}\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>With the following help message: <pre><code>$ python primitives.py --help\n&gt; usage: primitives.py [-h] --name TEXT --age INT --weight FLOAT --data BYTES (--flag | --no-flag)\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help      show this help message and exit\n&gt;   --name TEXT     (required)\n&gt;   --age INT       (required)\n&gt;   --weight FLOAT  (required)\n&gt;   --data BYTES    (required)\n&gt;   --flag\n&gt;   --no-flag\n</code></pre></p> <p>Note</p> <p>Observe that the <code>--flag</code> and <code>--no-flag</code> options are not marked as required. That is the expected behaviour: strictly speaking, taken individually, they are not required. However, being mutually exclusive, one of either <code>--flag</code> or <code>--no-flag</code> is still needed.</p> <p>`argdantic`` takes care of converting the provided fields into argparse arguments, so that the automatically generated description reamins as faithful as possible. Bear in mind that types are exploited only for documentation purposes, the final type checking will be carried out by pydantic. Most complex types are often interpreted as strings, unless specified otherwise.</p>"},{"location":"guide/types/#complex-types","title":"Complex types","text":"<p>Thanks to the powerful data definitions provided by pydantic, <code>argdantic</code> supports a large amount of complex types, Currently, the following types have been tested and supported:</p>"},{"location":"guide/types/#standard-library-types","title":"Standard Library types","text":"<p>Generally speaking, non-typed complex types will default to strings unless specified otherwise.</p> <ul> <li> <p><code>list</code>: without specifying the internal type, list fields will behave as multiple options of string items. Internally, argdantic exploits _argparse's <code>nargs</code> option to handle sequences. In this case, the argument can be repeated multiple times to build a list. For instance, <code>python cli.py --add 1 2</code> will result in a list <code>[1, 2]</code>.</p> </li> <li> <p><code>tuple</code>: similar to lists, this will behave as an unbounded sequence of strings, with multiple parameters.</p> </li> <li> <p><code>dict</code>: dictionaries are interpreted as JSON strings. In this case, there will be no further validation. Given that valid JSON strings require double quotes, arguments provided through the command line must use single-quoted strings. For instance, <code>python cli.py --extras '{\"items\": 12}'</code> will be successfully parsed, while <code>python cli.py --extras \"{'items': 12}\"</code> will not.</p> </li> <li> <p><code>set</code>: again, from a command line point of view, sets are a simple list of values. In this case, repeated values will be excluded. For instance, <code>python cli.py --add a --add b --add a</code> will result in a set <code>{'a', 'b'}</code>.</p> </li> <li> <p><code>frozenset</code>: frozen sets adopt the same behavior as normal sets, with the only difference that they remain immutable.</p> </li> <li> <p><code>deque</code>: similarly, deques act as sequences from a CLI standpoint, while being treaded as double-ended queues in code.</p> </li> <li> <p><code>range</code>: ranges are interpreted as a sequence of integers, with the same behavior as lists and tuples.</p> </li> </ul>"},{"location":"guide/types/#typing-containers","title":"Typing Containers","text":"<ul> <li> <p><code>Any</code>: For obvious reasons, Any fields will behave as <code>str</code> options without further processing.</p> </li> <li> <p><code>Optional</code>: optional typing can be interpreted as syntactic sugar, meaning it will not have any effect on the underlying validation, but it provides an explicit declaration that the field can also accept <code>None</code> as value.</p> </li> <li> <p><code>List</code>: Similar to standard lists, typing Lists behave as sequences of items. In this case however the inner type is exploited to provide further validation through pydantic. For instance, <code>python cli.py --add a --add b</code> will result in a validation error for a list of integers <code>List[int]</code>.</p> </li> <li> <p><code>Tuple</code>: typing Tuples can behave in two ways: when using a variable length structure (i.e., <code>Tuple[int]</code> or <code>Tuple[int, ...]</code>), tuples act as a sequence of typed items, validated through pydantic, where the parameter is specified multiple times. When using a _fixed length structure (i.e., <code>Tuple[int, int]</code> or similar), they are considered as fixed <code>nargs</code> options, where the parameter is specified once, followed by the sequence of values separated by whitespaces.  For instance . <code>python cli.py --items a b c</code> will results in a tuple <code>('a', 'b', 'c')</code>.  If the <code>items</code> tuple specified only two items, the command will result in a validation error.</p> </li> <li> <p><code>Dict</code>: Similar to the standard <code>dict</code> field, typing dictionaries require a JSON string as input. However, inner types allow for a finer validation: for instance, considering a <code>metrics: Dict[str, float]</code> field, <code>--metrics '{\"f1\": 0.93}'</code> is accepted, while <code>--metrics '{\"auc\": \"a\"}'</code> is not a valid input.</p> </li> <li> <p><code>Deque</code>: with the same reasoning of typed lists and tuples, Deques will act as sequences with a specific type.</p> </li> <li> <p><code>Set</code>: As you guessed, typed sets act as multiple options where repeated items are excluded, with additional type validation on the items themselves.</p> </li> <li> <p><code>FrozenSet</code>: as with Sets, but they represent immutable structures after parsing.</p> </li> <li> <p><code>Sequence</code> and <code>Iterables</code>: with no surpise, sequences and iterables act as sequences, nothing much to add here.</p> </li> </ul> <p>Warning</p> <p>for obvious reasons, <code>Union</code> typings are not supported at this time. Parsing a multi-valued parameter is really more of a phylosophical problem than a technical one. Future releases will consider the support for this typing.</p> <p>The code below provides a relatively comprehensive view of most container types supported through <code>argdantic</code>.</p> containers.py<pre><code>from typing import Deque, Dict, FrozenSet, List, Optional, Sequence, Set, Tuple\n\nfrom argdantic import ArgParser\n\ncli = ArgParser()\n\n\n@cli.command()\ndef run(\n    simple_list: list,\n    list_of_ints: List[int],\n    simple_tuple: tuple,\n    multi_typed_tuple: Tuple[int, float, str, bool],\n    simple_dict: dict,\n    dict_str_float: Dict[str, float],\n    simple_set: set,\n    set_bytes: Set[bytes],\n    frozen_set: FrozenSet[int],\n    none_or_str: Optional[str],\n    sequence_of_ints: Sequence[int],\n    compound: Dict[str, List[Set[int]]],\n    deque: Deque[int],\n):\n    print(f\"simple_list: {simple_list}\")\n    print(f\"list_of_ints: {list_of_ints}\")\n    print(f\"simple_tuple: {simple_tuple}\")\n    print(f\"multi_typed_tuple: {multi_typed_tuple}\")\n    print(f\"simple_dict: {simple_dict}\")\n    print(f\"dict_str_float: {dict_str_float}\")\n    print(f\"simple_set: {simple_set}\")\n    print(f\"set_bytes: {set_bytes}\")\n    print(f\"frozen_set: {frozen_set}\")\n    print(f\"none_or_str: {none_or_str}\")\n    print(f\"sequence_of_ints: {sequence_of_ints}\")\n    print(f\"compound: {compound}\")\n    print(f\"deque: {deque}\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Executing this script with the help command will provide the description for the current configuration. Also, defaults are allowed and validated.</p> <pre><code>$ python containers.py --help\n&gt; usage: containers.py [-h] --simple-list TEXT [TEXT ...] --list-of-ints INT [INT ...]\n&gt;   --simple-tuple TEXT [TEXT ...] --multi-typed-tuple INT FLOAT TEXT BOOL --simple-dict JSON\n&gt;   --dict-str-float JSON --simple-set TEXT [TEXT ...] --set-bytes BYTES [BYTES ...]\n&gt;   --frozen-set INT [INT ...] --none-or-str TEXT --sequence-of-ints INT [INT ...]\n&gt;   --compound JSON --deque INT [INT ...]\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help            show this help message and exit\n&gt;   --simple-list TEXT [TEXT ...]           (required)\n&gt;   --list-of-ints INT [INT ...]            (required)\n&gt;   --simple-tuple TEXT [TEXT ...]          (required)\n&gt;   --multi-typed-tuple INT FLOAT TEXT BOOL (required)\n&gt;   --simple-dict JSON                      (required)\n&gt;   --dict-str-float JSON                   (required)\n&gt;   --simple-set TEXT [TEXT ...]            (required)\n&gt;   --set-bytes BYTES [BYTES ...]           (required)\n&gt;   --frozen-set INT [INT ...]              (required)\n&gt;   --none-or-str TEXT                      (required)\n&gt;   --sequence-of-ints INT [INT ...]        (required)\n&gt;   --compound JSON                         (required)\n&gt;   --deque INT [INT ...]                   (required)\n</code></pre>"},{"location":"guide/types/#literals-and-enums","title":"Literals and Enums","text":"<p>Sometimes it may be useful to directly limit the choices of certain fields, by letting the user select among a fixed list of values. In this case, <code>argdantic</code> provides this feature using  pydantic's support for <code>Enum</code> and <code>Literal</code> types, parsed from the command line through the <code>choice</code> argument option.</p> <p>While Enums represent the standard way to provide choice-based options, Literals can be seen as a lightweight enumeration. In general, the latter are simpler and easier to handle than the former for most use cases. Enums on the other hand provide both a <code>name</code> and a <code>value</code> component, where only the former is exploited for the parameter definition. The latter can represent any kind of object, therefore making enums more suitable for more complex use cases.</p> <p>The following script presents a sample of possible choice definitions in clidantic: choices.py<pre><code>from enum import Enum, IntEnum\nfrom typing import Literal\n\nfrom argdantic import ArgParser\n\ncli = ArgParser()\n\n\nclass ToolEnum(Enum):\n    hammer = \"Hammer\"\n    screwdriver = \"Screwdriver\"\n\n\nclass HTTPEnum(IntEnum):\n    ok = 200\n    not_found = 404\n    internal_error = 500\n\n\n@cli.command()\ndef run(\n    a: Literal[\"one\", \"two\"] = \"two\",\n    b: Literal[1, 2] = 2,\n    c: Literal[True, False] = True,\n    d: ToolEnum = ToolEnum.hammer,\n    e: HTTPEnum = HTTPEnum.not_found,\n):\n    print(f\"a: {a}\")\n    print(f\"b: {b}\")\n    print(f\"c: {c}\")\n    print(f\"d: {d}\")\n    print(f\"e: {e}\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre></p> <p>Warning</p> <p>As you probably noticed, the string enumeration only subclasses <code>Enum</code>. Strictly speaking, <code>ToolEnum(str, Enum)</code> would be a better inheritance definition, however this breaks the type inference by providing two origins.</p> <p>Currently, there are two solutions:</p> <ul> <li>simply use Enum, it should be fine in most cases.</li> <li>use StrEnum, which however is only available since Python 3.11.</li> </ul> <p>Launching the help for this script will result in the following output: <pre><code>$ python choices.py --help\n&gt; usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]]\n&gt;\n&gt; optional arguments:\n&gt;   -h, --help            show this help message and exit\n&gt;   --a [one|two]                       (default: two)\n&gt;   --b [1|2]                           (default: 2)\n&gt;   --c [True|False]                    (default: True)\n&gt;   --d [hammer|screwdriver]            (default: ToolEnum.hammer)\n&gt;   --e [ok|not_found|internal_error]   (default: HTTPEnum.not_found)\n</code></pre></p> <p>You can notice that, even without explicit description, choice-based fields will automatically provide the list of possible values. Defaults also behave as expected: both literals and enums will accept any of the allowed values as default, and it that case the selected item will be displayed as default in the console. Again, note that the CLI exploits the <code>name</code> field in enum-based arguments for readability, not its actual value.</p> <p>Calling the script with a wrong choice will result in an error message, displaying the list of allowed values: <pre><code>$ python choices.py --a three\n&gt; usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]]\n&gt; choices.py: error: argument --a: invalid choice: three (choose from [one|two])\n</code></pre></p>"},{"location":"guide/types/#module-types","title":"Module types","text":"<p>Note</p> <p>Coming soon!</p>"}]}